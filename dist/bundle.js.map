{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;;;;;;AChf2H;AACrF;AAC/B;AACP;AACA;AACA,uBAAuB;AACvB,sBAAsB,gDAAY;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB,GAAG,sDAAc;AAC1D;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD,6CAA6C,UAAU,IAAI;AAC3D,gDAAgD,iBAAiB,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sDAAc;AACnD,2BAA2B,OAAO;AAClC,wBAAwB,aAAa,sEAAsE,MAAM;AACjH,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,yBAAyB,mBAAmB;AAChG,wBAAwB,6CAAK;AAC7B,4BAA4B,6CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yDAAiB;AACvE,gCAAgC,iDAAS,kCAAkC,wBAAwB;AACnG,2BAA2B,yDAAiB;AAC5C;AACA;AACA,mBAAmB,6CAAK;AACxB,wBAAwB,OAAO;AAC/B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,oDAAY;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5HO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnEgC;AACmB;AACf;AACE;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAY;AACtC,+BAA+B,mDAAU;AACzC,6BAA6B,+CAAQ;AACrC,0BAA0B,yCAAK;AAC/B;AACA,aAAa,mDAAU;AACvB,aAAa,qDAAY;AACzB,aAAa,qDAAY;AACzB,aAAa,sDAAa;AAC1B;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAY,GAAG,sCAAsC;AACjE,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,GAAG,SAAS;AACjE;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA,wCAAwC,0BAA0B;AAClE,wCAAwC,0BAA0B;AAClE,wCAAwC,0BAA0B;AAClE,wCAAwC,0BAA0B;AAClE;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACvEgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB,MAAM,eAAe;AACrF,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,6CAAK;AACjE;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,6DAA6D,WAAW;AACxE;AACA,sCAAsC,uBAAuB,UAAU,sBAAsB;AAC7F,+BAA+B,WAAW,IAAI,OAAO;AACrD,+BAA+B,WAAW,IAAI,OAAO;AACrD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sDAAsD,OAAO,IAAI,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB,UAAU,sBAAsB;AACvG,kDAAkD,UAAU,IAAI,OAAO;AACvE,mDAAmD,UAAU,IAAI,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uDAAuD,WAAW;AAClE;AACA,YAAY;AACZ,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK,QAAQ,WAAW,IAAI,MAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpO+B;AACxB;AACP;AACA;AACA;AACA,sCAAsC,aAAa,QAAQ,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,SAAS,wCAAI,GAAG,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtBO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD,oBAAoB;AACpB;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC1EA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN8B;AAC9B;AACA;AACA,iBAAiB,uCAAI;AACrB;AACA;AACA;AACA,CAAC;AACD","sources":["webpack://2048/./node_modules/events/events.js","webpack://2048/./src/board.ts","webpack://2048/./src/controller.ts","webpack://2048/./src/game.ts","webpack://2048/./src/renderer.ts","webpack://2048/./src/storage.ts","webpack://2048/./src/utils.ts","webpack://2048/webpack/bootstrap","webpack://2048/webpack/runtime/compat get default export","webpack://2048/webpack/runtime/define property getters","webpack://2048/webpack/runtime/hasOwnProperty shorthand","webpack://2048/webpack/runtime/make namespace object","webpack://2048/./src/index.ts"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import { calcCoordsByIndex, calcIndexByCoords, generateId, isPowerOfTwo, matrixIterator, randomize, range } from \"./utils\";\nimport { EventEmitter } from \"events\";\nexport class Board {\n    constructor(boardSize) {\n        this.boardSize = boardSize;\n        this.state = { cells: [] };\n        this.ee = new EventEmitter();\n    }\n    onUpdate(handler) {\n        this.ee.addListener(Board.UPDATE_EVENT, (prevState) => handler(this.state, prevState));\n    }\n    restore(cells) {\n        this.setState({ cells });\n    }\n    reset() {\n        this.setState({ cells: [] });\n    }\n    move(axis, step) {\n        var _a;\n        const boardSize = this.boardSize;\n        let hasMoved = false;\n        const mtxBefore = this.getBoardMatrix();\n        const mtx = this.getBoardMatrix();\n        const mergedKeys = new Set();\n        for (const { value: cell, x, y } of matrixIterator(mtx, axis, Math.sign(step) > 0)) {\n            if (!cell)\n                continue; // skip empty values\n            const canMove = (pointer) => (Math.sign(step) > 0 ? pointer < boardSize - 1 : pointer > 0);\n            const initialPointer = axis === \"x\" ? x : y;\n            // Каждую непустую ячейку мы двигаем по оси, до тех пор пока:\n            // - Доходим до края\n            // - Доходим до ячейки с таким же значением (необходимо слить соседнии ячейки и пометить ее, тк складывать можно только 1 раз)\n            for (let p = initialPointer; canMove(p); p += step) {\n                const pos = axis === \"x\" ? { y, x: p } : { y: p, x };\n                const sibPos = axis === \"x\" ? { y, x: p + step } : { y: p + step, x };\n                const sibling = (_a = mtx[sibPos.y]) === null || _a === void 0 ? void 0 : _a[sibPos.x];\n                if (sibling === null) {\n                    // соседняя ячейка свободна - передвигаем текущую клетку\n                    [mtx[pos.y][pos.x], mtx[sibPos.y][sibPos.x]] = [mtx[sibPos.y][sibPos.x], mtx[pos.y][pos.x]];\n                    hasMoved = true;\n                    continue;\n                }\n                if (sibling.value === cell.value && !mergedKeys.has(cell.key) && !mergedKeys.has(sibling.key)) {\n                    // merge values (using sib cell) and mark it as merged\n                    cell.doubleValue();\n                    mtx[sibPos.y][sibPos.x] = cell;\n                    mtx[pos.y][pos.x] = null;\n                    mergedKeys.add(cell.key);\n                    hasMoved = true;\n                    break;\n                }\n                break;\n            }\n        }\n        if (hasMoved) {\n            // Конвертируем матрицу в массив ячеек и синхронизируем (координаты)\n            const cells = Array.from(matrixIterator(mtx))\n                .filter(({ value }) => value !== null)\n                .map(({ value, x, y }) => (value === null || value === void 0 ? void 0 : value.setCoords({ x, y }), value));\n            this.setState({ cells });\n        }\n        return hasMoved;\n    }\n    setState(patch) {\n        const prevState = this.state;\n        this.state = Object.assign(Object.assign({}, prevState), patch);\n        this.ee.emit(Board.UPDATE_EVENT, prevState);\n    }\n    getBoardMatrix() {\n        var _a;\n        const boardSize = this.boardSize;\n        const cells = this.state.cells;\n        const mtx = Array.from({ length: boardSize }).map(() => Array.from({ length: boardSize }));\n        for (const x of range(mtx.length)) {\n            for (const y of range(mtx.length)) {\n                mtx[y][x] = (_a = cells.find((cell) => cell.x === x && cell.y === y)) !== null && _a !== void 0 ? _a : null;\n            }\n        }\n        return mtx;\n    }\n    spawnCells(count) {\n        const boardSize = this.boardSize;\n        const cells = [...this.state.cells];\n        const createSpawnCell = () => {\n            const INITIAL_VALUE = 2;\n            const filledIndexes = cells.map((cell) => calcIndexByCoords(cell.coords, boardSize));\n            const randomIndex = randomize(0, Math.pow(boardSize, 2) - 1, { exclude: filledIndexes });\n            const coords = calcCoordsByIndex(randomIndex, boardSize);\n            return new Cell(coords, INITIAL_VALUE);\n        };\n        Array.from(range(count)).forEach(() => cells.push(createSpawnCell()));\n        this.setState({ cells });\n    }\n}\nBoard.UPDATE_EVENT = \"STATE_CHANGED_EVENT\";\nexport class Cell {\n    constructor(coords, value) {\n        this.value = value;\n        this.key = null;\n        this.x = null;\n        this.y = null;\n        this.validateValue(value);\n        this.x = coords.x;\n        this.y = coords.y;\n        this.key = generateId();\n    }\n    doubleValue() {\n        // @ts-ignore\n        this.value = this.value * 2;\n    }\n    setCoords(coords) {\n        // @ts-ignore\n        this.x = coords.x;\n        // @ts-ignore\n        this.y = coords.y;\n    }\n    get coords() {\n        return { x: this.x, y: this.y };\n    }\n    validateValue(value) {\n        if (!isPowerOfTwo(value)) {\n            throw TypeError(\"Value must be a power of 2\");\n        }\n    }\n}\n","export var Command;\n(function (Command) {\n    Command[Command[\"LEFT\"] = 0] = \"LEFT\";\n    Command[Command[\"UP\"] = 1] = \"UP\";\n    Command[Command[\"RIGHT\"] = 2] = \"RIGHT\";\n    Command[Command[\"DOWN\"] = 3] = \"DOWN\";\n})(Command || (Command = {}));\nexport class Controller {\n    constructor() {\n        this.KEY_MAP = {\n            w: Command.UP,\n            ArrowUp: Command.UP,\n            s: Command.DOWN,\n            ArrowDown: Command.DOWN,\n            a: Command.LEFT,\n            ArrowLeft: Command.LEFT,\n            d: Command.RIGHT,\n            ArrowRight: Command.RIGHT,\n        };\n    }\n    listenCommand(handler) {\n        const keysUnsubscribe = this.keysListen(handler);\n        const gestureUnsubscribe = this.gestureListen(handler);\n        return {\n            unsubscribe: () => {\n                keysUnsubscribe();\n                gestureUnsubscribe();\n            },\n        };\n    }\n    keysListen(handler) {\n        const listener = (event) => {\n            const controlledKey = this.KEY_MAP[event.key];\n            if (controlledKey !== undefined)\n                handler(controlledKey, event);\n        };\n        document.addEventListener(\"keydown\", listener);\n        return () => {\n            document.removeEventListener(\"keydown\", listener);\n        };\n    }\n    gestureListen(handler) {\n        let touchstartX = 0;\n        let touchstartY = 0;\n        const touchStartListener = (e) => {\n            touchstartX = e.changedTouches[0].screenX;\n            touchstartY = e.changedTouches[0].screenY;\n        };\n        const touchEndListener = (e) => {\n            const touchendX = e.changedTouches[0].screenX;\n            const touchendY = e.changedTouches[0].screenY;\n            if (touchendX < touchstartX)\n                handler(Command.LEFT, e);\n            else if (touchendX > touchstartX)\n                handler(Command.RIGHT, e);\n            else if (touchendY < touchstartY)\n                handler(Command.UP, e);\n            else if (touchendY > touchstartY)\n                handler(Command.DOWN, e);\n        };\n        document.addEventListener(\"touchstart\", touchStartListener);\n        document.addEventListener(\"touchend\", touchEndListener);\n        return () => {\n            document.removeEventListener(\"touchstart\", touchStartListener);\n            document.removeEventListener(\"touchend\", touchEndListener);\n        };\n    }\n}\n","import { Board } from \"./board\";\nimport { Command, Controller } from \"./controller\";\nimport { Storage } from \"./storage\";\nimport { Renderer } from \"./renderer\";\nexport class Game {\n    constructor(cfg) {\n        this.cfg = cfg;\n    }\n    bootstrap() {\n        var _a;\n        const resetButton = document.getElementById(\"reset-button\");\n        const currentScoreValue = document.getElementById(\"current-score-value\");\n        const persisted = Storage.load();\n        const controller = new Controller();\n        const renderer = new Renderer(this.cfg.boardElement, this.cfg.boardSize);\n        const board = new Board((_a = persisted === null || persisted === void 0 ? void 0 : persisted.boardSize) !== null && _a !== void 0 ? _a : this.cfg.boardSize);\n        const moveHandler = {\n            [Command.UP]: () => board.move(\"y\", -1),\n            [Command.DOWN]: () => board.move(\"y\", 1),\n            [Command.LEFT]: () => board.move(\"x\", -1),\n            [Command.RIGHT]: () => board.move(\"x\", 1),\n        };\n        board.onUpdate(({ cells }) => {\n            if (this.isGameOver(cells)) {\n                alert(\"Game Over!\");\n                board.reset();\n                board.spawnCells(2);\n                return;\n            }\n            const score = cells.reduce((acc, cell) => acc + cell.value, 0);\n            currentScoreValue.innerHTML = String(score);\n            renderer.render(cells);\n            Storage.save({ cells, boardSize: this.cfg.boardSize });\n        });\n        resetButton.addEventListener(\"click\", () => {\n            board.reset();\n            board.spawnCells(2);\n        });\n        controller.listenCommand((key) => {\n            const move = moveHandler[key];\n            const hasMoved = move();\n            // spawn cell if has moved\n            if (hasMoved)\n                board.spawnCells(1);\n        });\n        if (persisted) {\n            board.restore(persisted.cells);\n        }\n        else {\n            board.reset();\n            board.spawnCells(2);\n        }\n        renderer.mount();\n    }\n    isGameOver(cells) {\n        const getCoordsKey = (coords) => `${coords.x}x${coords.y}`;\n        const noEmptyCells = cells.length === Math.pow(this.cfg.boardSize, 2);\n        if (!noEmptyCells) {\n            return false;\n        }\n        const cellsMap = cells.reduce((acc, cell) => ((acc[getCoordsKey(cell.coords)] = cell), acc), {});\n        return cells.every((cell) => {\n            const siblings = [\n                cellsMap[getCoordsKey({ x: cell.x + 1, y: cell.y })],\n                cellsMap[getCoordsKey({ x: cell.x - 1, y: cell.y })],\n                cellsMap[getCoordsKey({ x: cell.x, y: cell.y + 1 })],\n                cellsMap[getCoordsKey({ x: cell.x, y: cell.y - 1 })],\n            ];\n            return siblings.every((sib) => !sib || sib.value !== cell.value);\n        });\n    }\n}\n","import { range } from \"./utils\";\n/**\n * Отрисовка происходит в несколько этапов\n * Первоначально мы рисуем все клетки в обычном порядке, для каждой клетки мы должны хранить, атрибут с ее ключом\n * При перерисовке мы должны вычислить, изначальный порядок относительно каждой клетки, и применить transform, к тем чей\n * порядок изменился, а также обновить все значения (value etc)\n *\n * При перерисовке, мы также должны удалить неиспользуемые элементы\n */\nexport class Renderer {\n    constructor(boardElement, boardSize) {\n        this.boardElement = boardElement;\n        this.boardSize = boardSize;\n        this.renderCleanup = [];\n        this.boardGridElement = null;\n        this.boardSceneElement = null;\n        this.createHooks = () => {\n            this.renderCleanup.forEach((cleanup) => cleanup());\n            this.renderCleanup = [];\n            // let transitionStarted = false;\n            // const alreadyHandled = new Set<VoidFunction>();\n            // const _beforeTransitionHandler = () => {\n            //     transitionStarted = true;\n            // };\n            // this.boardSceneElement.addEventListener(\"transitionstart\", _beforeTransitionHandler);\n            // this.renderCleanup.push(() => this.boardSceneElement.removeEventListener(\"transitionstart\", _beforeTransitionHandler));\n            const afterTransition = (callback) => {\n                // const handler = () => {\n                //     if (!alreadyHandled.has(callback)) {\n                //         callback();\n                //         alreadyHandled.add(callback);\n                //     }\n                // };\n                // if (!transitionStarted) {\n                //     handler();\n                //     return;\n                // }\n                const timerID = window.setTimeout(callback, Renderer.MOVE_TRANSITION_MS);\n                this.renderCleanup.push(() => clearTimeout(timerID));\n                // this.boardSceneElement.addEventListener(\"transitionend\", handler);\n                // this.boardSceneElement.addEventListener(\"transitioncancel\", handler);\n                // this.renderCleanup.push(\n                //     () => this.boardSceneElement.removeEventListener(\"transitionend\", handler),\n                //     () => this.boardSceneElement.removeEventListener(\"transitioncancel\", handler)\n                // );\n            };\n            return { afterTransition };\n        };\n        this.boardGridElement = boardElement.querySelector(\".board-grid\");\n        this.boardSceneElement = boardElement.querySelector(\".board-scene\");\n    }\n    static getCSSVar(name) {\n        return getComputedStyle(document.documentElement).getPropertyValue(name);\n    }\n    static setCSSVar(name, value) {\n        return document.documentElement.style.setProperty(name, value);\n    }\n    mount() {\n        const cellSizeCSS = `calc(var(${Renderer.BOARD_SIZE_VAR}) / ${this.boardSize})`;\n        const cellGapCSS = `calc(var(${Renderer.CELL_SIZE_VAR}) * 0.04) `;\n        Renderer.setCSSVar(Renderer.CELL_SIZE_VAR, cellSizeCSS);\n        Renderer.setCSSVar(Renderer.CELL_GAP_VAR, cellGapCSS);\n        const createEmptyCell = () => {\n            const element = document.createElement(\"div\");\n            element.classList.add(\"cell\", \"cell-empty\");\n            return element;\n        };\n        this.boardGridElement.replaceChildren(...Array.from(range(Math.pow(this.boardSize, 2))).map(() => createEmptyCell()));\n    }\n    static createCellElement(cell) {\n        return Renderer.updateCellElement(cell, document.createElement(\"div\"), true);\n    }\n    static updateCellElement(cell, element, useAbsolute) {\n        element.className = \"\"; // cleanup all classNames before\n        element.classList.add(\"cell\", \"cell-filled\", `cell-${cell.value}`);\n        element.setAttribute(\"data-key\", cell.key);\n        const shiftStep = `calc(var(${Renderer.CELL_SIZE_VAR}) + var(${Renderer.CELL_GAP_VAR}) * 0.25)`;\n        const xShift = `calc(${shiftStep} * ${cell.x})`;\n        const yShift = `calc(${shiftStep} * ${cell.y})`;\n        // if (useAbsolute) {\n        //     element.style.transform = \"\";\n        //     element.style.top = xShift;\n        //     element.style.left = yShift;\n        // } else {\n        //     element.style.top = \"\";\n        //     element.style.left = \"\";\n        //     element.style.transform = `translate(${xShift}, ${yShift})`;\n        // }\n        element.style.transform = \"\";\n        element.style.top = yShift;\n        element.style.left = xShift;\n        element.innerHTML = String(cell.value);\n        return element;\n    }\n    getSceneCellElements() {\n        return Array.from(this.boardElement.querySelectorAll(\".board-scene .cell\"));\n    }\n    render(cells) {\n        const hooks = this.createHooks();\n        const cellElements = this.getSceneCellElements();\n        const currentKeys = new Set(cells.map((c) => c.key));\n        const getDataKey = (el) => String(el.getAttribute(\"data-key\"));\n        const getElementByKey = (key) => cellElements.find((el) => getDataKey(el) === key);\n        // const getCellByKey = (key: string) => cells.find((cell) => cell.key === key);\n        if (!cellElements.length) {\n            this.boardSceneElement.replaceChildren(...cells.map((cell) => Renderer.createCellElement(cell)));\n            return;\n        }\n        // creating new cells and updating an existed\n        for (const cell of cells) {\n            const element = getElementByKey(cell.key);\n            if (!element) {\n                // create new element\n                const newElement = Renderer.createCellElement(cell);\n                // newElement.style.transform = \"\";\n                // const shiftCSS = `calc(var(${Renderer.CELL_SIZE_VAR}) + var(${Renderer.CELL_GAP_VAR}) * 0.25)`;\n                // newElement.style.top = `calc(${shiftCSS} * ${cell.x})`;\n                // newElement.style.left = `calc(${shiftCSS} * ${cell.y})`;\n                // newElement.classList.add('no-transition')\n                // hooks.afterTransition(() => this.boardSceneElement.append(newElement));\n                // this.boardSceneElement.append(newElement);\n                // this.boardSceneElement.append(newElement);\n                hooks.afterTransition(() => this.boardSceneElement.append(newElement));\n                continue;\n            }\n            Renderer.updateCellElement(cell, element);\n        }\n        const removedElements = cellElements.filter((el) => !currentKeys.has(getDataKey(el)));\n        for (const removedEl of removedElements) {\n            // hooks.afterTransition(() => removedEl.remove());\n            removedEl.remove();\n        }\n        // this.boardSceneElement.replaceChildren(...cells.map((cell) => Renderer.createCellElement(cell)));\n        // cells.forEach((cell) => {\n        // const key = cell.key;\n        // const el = getElementByKey(key);\n        // // Заменяем удаленные элементы на новые\n        // if (!el) {\n        //     // hack for animation\n        //     const newEl = Renderer.createCellElement(cell);\n        //     newEl.classList.add(\"no-appear\", \"cell-empty\");\n        //     insertChildAtIndex(this.boardElement, newEl, cell.position);\n        //     let interrupted = false;\n        //     setTimeout(() => !interrupted && newEl.replaceWith(Renderer.createCellElement(cell)), 100);\n        //     this.cleanupCbsBeforeRerender.push(() => void (interrupted = true));\n        //     return;\n        // }\n        // el.classList.forEach((className) => /cell-\\d+/.test(className) && el!.classList.remove(className));\n        // el.innerHTML = !cell.isEmpty() ? String(cell.value) : \"\";\n        // if (cell.isEmpty()) {\n        //     el.classList.remove(\"cell-filled\");\n        // } else {\n        //     el.classList.add(\"cell-filled\", `cell-${cell.value}`);\n        // }\n        // });\n        // const cells = [..._cells].sort((a, b) => calcIndexByCoords(a.coords, this.boardSize) - calcIndexByCoords(b.coords, this.boardSize)); // sorted cells\n        // this.cleanupCbsBeforeRerender.forEach((cb) => cb());\n        // this.cleanupCbsBeforeRerender = [];\n        // const relevantKeys = new Set(cells.map((cell) => cell.key));\n        // const allCellElements = this.getAllCellElements();\n        // const getDataKey = (el: HTMLElement) => String(el.getAttribute(\"data-key\"));\n        // const getElementByKey = (key: string) => allCellElements.find((el) => getDataKey(el) === key);\n        // const getCellByKey = (key: string) => cells.find((cell) => cell.key === key);\n        // if (allCellElements.length !== cells.length) {\n        //     this.initialRender(cells);\n        //     return;\n        // }\n        // // ! cleanup\n        // // Этап, на котором удаляем неиспользуемые DOM элементы\n        // // Это пустые клетки, на месте которых должны появиться новые значения\n        // allCellElements.forEach((el) => {\n        //     if (!relevantKeys.has(getDataKey(el))) {\n        //         el.remove();\n        //     }\n        // });\n        // // ! hydrate\n        // // Этап, на котором мы синхронизируем данные с состоянием в DOM\n        // // Здесь мы не меняем порядок DOM элементов, только актуализируем содержание ячейки по\n        // // соответствующему ключу, или создаем новую, если ее нет в DOM\n        // // ! animate\n        // // Здесь мы должны на основе актуального дом дерева и состояния передвинуть клетки,\n        // // используя css, так, чтобы все стало на свои места\n        // this.getAllCellElements().forEach((el, viewPosition) => {\n        //     const key = getDataKey(el);\n        //     const cell = getCellByKey(key)!;\n        //     const actualCoords = cell.coords;\n        //     const viewCoords = calcCoordsByIndex(viewPosition, cell.boardsSize);\n        //     const coordsDiff = {\n        //         x: actualCoords.x - viewCoords.x,\n        //         y: actualCoords.y - viewCoords.y,\n        //     };\n        //     const transforms: string[] = [];\n        //     const makeTranslate = (axis: \"X\" | \"Y\", value: number) => {\n        //         const outerSize = \"calc(var(--cell-size) + var(--cell-gap) * 0.25)\";\n        //         return `translate${axis}(calc(${outerSize} * ${value}))`;\n        //     };\n        //     if (coordsDiff.x) {\n        //         transforms.push(makeTranslate(\"X\", coordsDiff.x));\n        //     }\n        //     if (coordsDiff.y) {\n        //         transforms.push(makeTranslate(\"Y\", coordsDiff.y));\n        //     }\n        //     el.style.transform = transforms.join(\" \");\n        // });\n        // let processing = false;\n        // const onTransitionFinished = () => {\n        //     if (!processing) {\n        //         processing = true;\n        //         const children = this.getAllCellElements();\n        //         const getPos = (el: HTMLElement) => getCellByKey(getDataKey(el))!.position;\n        //         children.forEach((el) => {\n        //             el.style.transform = \"\";\n        //             el.classList.add(\"no-appear\");\n        //         });\n        //         this.boardElement.replaceChildren(...children.sort((a, b) => getPos(a) - getPos(b)));\n        //     }\n        // };\n        // this.boardElement.addEventListener(\"transitionend\", onTransitionFinished);\n        // // this.boardElement.addEventListener(\"transitioncancel\", onTransitionFinished);\n        // this.cleanupCbsBeforeRerender.push(\n        //     () => this.boardElement.removeEventListener(\"transitionend\", onTransitionFinished)\n        //     // () => this.boardElement.removeEventListener(\"transitioncancel\", onTransitionFinished)\n        // );\n    }\n}\nRenderer.CELL_GAP_VAR = \"--cell-gap\";\nRenderer.CELL_SIZE_VAR = \"--cell-size\";\nRenderer.BOARD_SIZE_VAR = \"--board-size\";\nRenderer.MOVE_TRANSITION_MS = 100;\n","import { Cell } from \"./board\";\nexport class Storage {\n    static save(state) {\n        const json = {\n            boardSize: state.boardSize,\n            cells: state.cells.map(({ x, y, value }) => ({ x, y, value })),\n        };\n        localStorage.setItem(this.LS_KEY, JSON.stringify(json));\n    }\n    static load() {\n        try {\n            const parsed = JSON.parse(localStorage.getItem(this.LS_KEY));\n            return {\n                boardSize: parsed.boardSize,\n                cells: parsed.cells.map(({ x, y, value }) => new Cell({ x, y }, value)),\n            };\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\nStorage.LS_KEY = \"game-state\";\n","export const randomize = (min, max, cfg) => {\n    const value = Math.floor(Math.random() * (max - min + 1) + min);\n    if (!(cfg === null || cfg === void 0 ? void 0 : cfg.exclude.includes(value))) {\n        return value;\n    }\n    return randomize(min, max, cfg);\n};\nexport const isPowerOfTwo = (value) => {\n    return (Math.log(value) / Math.log(2)) % 1 === 0;\n};\nexport const range = function* (fromOrTo, to, step = 1) {\n    let start = to !== undefined ? fromOrTo : 0;\n    let end = to !== undefined ? to : fromOrTo;\n    const reversed = Math.sign(step) < 0;\n    if (reversed) {\n        [start, end] = [end - 1, start - 1];\n    }\n    for (let i = start; reversed ? i > end : i < end; i += step) {\n        yield i;\n    }\n};\n/**\n * Генерирует короткий ID\n */\nexport const generateId = () => \"_\" + Math.random().toString(36).slice(2, 9);\nexport const insertChildAtIndex = (parent, child, index) => {\n    if (!index)\n        index = 0;\n    if (index >= parent.children.length) {\n        parent.appendChild(child);\n    }\n    else {\n        parent.insertBefore(child, parent.children[index]);\n    }\n};\nexport const calcCoordsByIndex = (index, boardSize) => {\n    const x = index % boardSize;\n    const y = Math.floor(index / boardSize);\n    return { x, y };\n};\nexport const calcIndexByCoords = (coords, boardSize) => {\n    return coords.x + coords.y * boardSize;\n};\nexport function* matrixIterator(matrix, pivotAxis = \"x\", reversed) {\n    const size = matrix.length;\n    for (const a1 of range(size)) {\n        for (const a2 of range(0, size, reversed ? -1 : 1)) {\n            const [x, y] = pivotAxis === \"x\" ? [a2, a1] : [a1, a2];\n            const value = matrix[y][x];\n            const index = calcIndexByCoords({ x, y }, size);\n            yield { value, x, y, index };\n        }\n    }\n}\nexport const isObject = (value) => typeof value === \"object\" && value != null;\nexport const deepEqual = (a, b) => {\n    // P1\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (Object.is(a, b)) {\n        return true;\n    }\n    // P2\n    if (!isObject(a) || !isObject(b)) {\n        return false;\n    }\n    // P3\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    return keysA.every((key) => deepEqual(a[key], b[key]));\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Game } from \"./game\";\nconst boardElement = document.getElementById(\"board-root\");\nconst scoreValueElement = document.getElementById(\"score-value\");\nconst game = new Game({\n    scoreValueElement,\n    boardElement,\n    boardSize: 4,\n});\ngame.bootstrap();\n"],"names":[],"sourceRoot":""}